- [What is BIgO](https://youtu.be/Mo4vesaut8g?si=rv5RFxNU3zyUvhnG&t=47)

  - Used to analyze efficiency of algorithms(time complexity) as input size grows
  - Focuses on worst-case scenario
  - Ignores constant factors(ex: lines of code that take constant time) and lower-order terms(terms that become insignificant as input size grows)
  - Common Big O notations:
    - O(1): Constant time
    - O(log n): Logarithmic time
    - O(n): Linear time
    - O(n log n): Linearithmic time
    - O(n^2): Quadratic time
    - O(2^n): Exponential time
    - O(n!): Factorial time

- More precisely, constants are something that doesn't change with the size of the input.

Examples:

- If x amount of time a doctor takes to treat one patient, then amount of time taken to treat n patients is **_O(n)_**

  - [function example of linear time O(n)](https://youtu.be/Mo4vesaut8g?si=_4ZL-ADIhcgIL4wF&t=167)

- [Big O(1) explained](https://youtu.be/Mo4vesaut8g?si=6Eh2TEF3AILLsiX-&t=247)

- [Orders of Growth, efficiency category](https://youtu.be/Mo4vesaut8g?si=b03uqfapd1r452C4&t=307)

- To calculate the efficiency of fuction

  1. Identify efficiency of each line of code
  2. Add them up
  3. Give priority to the highest order step or we can say worst performance.

- [O(n^2)](https://youtu.be/Mo4vesaut8g?si=cx7YkCWp1AmPvuA2&t=437)
- [O(n^3)](https://youtu.be/Mo4vesaut8g?si=vHNHqQ_BgwvsPmbs&t=847)
- [O(log n, iterative and non recursive and recursive)](https://youtu.be/Mo4vesaut8g?si=mH0GmYUqTaApNw7W&t=1597)
  - [Binary Search O(log n)](https://youtu.be/Mo4vesaut8g?si=EpquQNUO_vwMIJbb&t=2177)
  - [Binary Search O(n log n)](https://youtu.be/Mo4vesaut8g?si=WA1KCZJQUVrer3Vp&t=3497)
